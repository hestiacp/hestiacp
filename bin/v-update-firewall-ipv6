#!/bin/bash
# info: update system IPv6 firewall rules
# options: NONE
#
# example: v-update-firewall-ipv6
#
# This function updates ip6tables rules

#----------------------------------------------------------#
#                Variables & Functions                     #
#----------------------------------------------------------#

ip6tables="/sbin/ip6tables"
modprobe="/sbin/modprobe"
sysctl="/sbin/sysctl"

# Includes
source /etc/profile.d/hestia.sh
source /etc/hestiacp/hestia.conf
source "$HESTIA/func/main.sh"
source "$HESTIA/func/firewall.sh"
source_conf "$HESTIA/conf/hestia.conf"

#----------------------------------------------------------#
#                    Verifications                         #
#----------------------------------------------------------#

is_system_enabled "$FIREWALL_SYSTEM" 'FIREWALL_SYSTEM'

#----------------------------------------------------------#
#                       Action                             #
#----------------------------------------------------------#

rules="$HESTIA/data/firewall/rules6.conf"
chains="$HESTIA/data/firewall/chains6.conf"
banlist="$HESTIA/data/firewall/banlist6.conf"

# Ensure rule files exist
[ -f "$rules" ] || touch "$rules"
[ -f "$chains" ] || touch "$chains"
[ -f "$banlist" ] || touch "$banlist"

# Load IPv6 ipset lists if present
[ -x "$BIN/v-update-firewall-ipset-ipv6" ] && "$BIN/v-update-firewall-ipset-ipv6" load 2> /dev/null

# Creating temporary file
tmp="$(mktemp)"

# Flush INPUT chain and set default policy
echo "$ip6tables -P INPUT ACCEPT" >> "$tmp"
echo "$ip6tables -F INPUT" >> "$tmp"

# Enable stateful support
echo "$ip6tables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT" >> "$tmp"

# Accept localhost traffic (::1)
echo "$ip6tables -A INPUT -s ::1 -j ACCEPT" >> "$tmp"

# Parse and apply all main rules (rules6.conf)
IFS=$'\n'
for line in $(sort -n -k 2 -t \' "$rules"); do
	parse_object_kv_list "$line"
	if [ "$SUSPENDED" = 'no' ]; then
		proto="-p $PROTOCOL"
		port="--dport $PORT"
		state=""
		action="-j $ACTION"

		if [[ "$IP6" =~ ^ipset: ]]; then
			ipset_name="${IP6#ipset:}"
			[ -x "$BIN/v-list-firewall-ipset-ipv6" ] && "$BIN/v-list-firewall-ipset-ipv6" plain | grep "^$ipset_name\s" > /dev/null \
				|| log_event $E_NOTEXIST "IPset IP list ($ipset_name) not found"
			ip="-m set --match-set '${ipset_name}' src"
		else
			ip="-s $IP6"
		fi

		# Multiport module for ranges
		if [[ "$PORT" =~ ,|-|: ]]; then
			port="-m multiport --dports ${PORT//-/:}"
		fi

		# Accepting all dst ports for 0/ICMP
		if [[ "$PORT" = "0" ]] || [ "$PROTOCOL" = 'ICMP' ]; then
			port=""
		fi

		echo "$ip6tables -A INPUT $proto $port $ip $state $action" >> "$tmp"
	fi
done

# Set policy to DROP after rules
echo "$ip6tables -P INPUT DROP" >> "$tmp"

# Add hestia chain (placeholder, can be used for future)
echo "$ip6tables -N hestia" >> "$tmp"

# Applying base rules
bash "$tmp" 2> /dev/null
rm -f "$tmp"

#----------------------------------------------------------#
#                   Chains & Fail2Ban IPv6                 #
#----------------------------------------------------------#

if [ -n "$FIREWALL_EXTENSION" ]; then
	# Custom chains
	if [ -s "$chains" ]; then
		tmp_chain="$(mktemp)"
		while IFS= read -r chain; do
			parse_object_kv_list "$chain"
			if [[ "$PORT" =~ ,|-|: ]]; then
				port="-m multiport --dports $PORT"
			else
				port="--dport $PORT"
			fi
			echo "$ip6tables -N fail2ban-$CHAIN" >> "$tmp_chain"
			echo "$ip6tables -F fail2ban-$CHAIN" >> "$tmp_chain"
			echo "$ip6tables -I fail2ban-$CHAIN -s ::/0 -j RETURN" >> "$tmp_chain"
			echo "$ip6tables -I INPUT -p $PROTOCOL $port -j fail2ban-$CHAIN" >> "$tmp_chain"
		done < "$chains"
		bash "$tmp_chain" 2> /dev/null
		rm -f "$tmp_chain"
	fi

	# Banlist for blocked IPs
	if [ -s "$banlist" ]; then
		tmp_ban="$(mktemp)"
		while IFS= read -r ban; do
			parse_object_kv_list "$ban"
			# Insert to fail2ban chain (explicit REJECT)
			echo -n "$ip6tables -I fail2ban-$CHAIN 1 -s $IP" >> "$tmp_ban"
			echo " -j REJECT --reject-with icmp6-port-unreachable" >> "$tmp_ban"
		done < "$banlist"
		bash "$tmp_ban" 2> /dev/null
		rm -f "$tmp_ban"
	fi
fi

# Custom trigger for IPv6
if [ -x "$HESTIA/data/firewall/custom6.sh" ]; then
	bash "$HESTIA/data/firewall/custom6.sh"
fi

# Save rules for systemd/service restore
if [ -d "/etc/sysconfig" ]; then
	/sbin/ip6tables-save > /etc/sysconfig/ip6tables
else
	/sbin/ip6tables-save > /etc/ip6tables.rules
	sd_unit="/lib/systemd/system/hestia-ip6tables.service"
	if [ ! -e "$sd_unit" ]; then
		echo "[Unit]" >> $sd_unit
		echo "Description=Loading Hestia IPv6 firewall rules" >> $sd_unit
		echo "DefaultDependencies=no" >> $sd_unit
		echo "Wants=network-pre.target local-fs.target" >> $sd_unit
		echo "Before=network-pre.target" >> $sd_unit
		echo "After=local-fs.target" >> $sd_unit
		echo "" >> $sd_unit
		echo "[Service]" >> $sd_unit
		echo "Type=oneshot" >> $sd_unit
		echo "RemainAfterExit=yes" >> $sd_unit
		echo "ExecStartPre=-${HESTIA}/bin/v-update-firewall-ipset-ipv6 load" >> $sd_unit
		echo "ExecStart=/sbin/ip6tables-restore /etc/ip6tables.rules" >> $sd_unit
		echo "" >> $sd_unit
		echo "[Install]" >> $sd_unit
		echo "WantedBy=multi-user.target" >> $sd_unit
		systemctl -q daemon-reload
	fi
	systemctl -q is-enabled hestia-ip6tables 2> /dev/null || systemctl -q enable hestia-ip6tables
fi

exit
